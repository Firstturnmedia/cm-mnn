<?php


/**
 * @file
 */


/**
 * Implements hook_schema().
 * Creates the custom tables for the caching layer of reservations
 */
function cma_reservation_cache_schema() {
  $schema['cma_reservation_group'] =
    array(
	  'description' => 'For grouping cached reservations to allow ' .
	  'things like partial returns.',
	  'fields' =>
	  array(
		'id' =>
		array(
		      'type' => 'serial',
		      'description' => 'Group ID',
		      ),
		),
	  'indexes' =>
	  array(
		'id' => array('id'),
		),
	  'primary key' => array('id'),
	  );
  //EACH ROW IN THIS TABLE IS A RESERVATION IN A GROUP
  $schema['cma_reservation_group_item'] =
    array(
	  'description' =>
	  'A reservation in a group, for things like partial returns.',
	  'fields' =>
	  array(
		'id' => array(
			      'type' => 'serial',
			      'description' => 'Group ID',
			      ),
		'reservation_group_id' => array(
						'type' => 'int',
						'unsigned' => TRUE,
						'not null' => TRUE,
						),
		'reservation_id' => array(
					  'type' => 'int',
					  'unsigned' => TRUE,
					  'not null' => TRUE,
					  ),
		),
	  'indexes' =>
	  array(
		'id' => array('id'),
		'reservation_group_id' =>
		array('reservation_group_id'),
		'reservation_id' => array('reservation_id'),
		),
	  'primary key' => array('id'),
	  );

  //these are the main cache fields for the cma_reservation_cache
  $main_cache_fields = cma_reservation_cache_main_cache_fields();
    
  $indexes = array();
  foreach ($main_cache_fields as $field=>$field_info) {
    $indexes[$field] = array($field);
  }
  
  $schema['cma_reservation_cache'] =
    array(
	  'description' =>
	  'This is the main cache table for all nodes with content types ' .
	  'enabled for reservations.',
	  'fields' => cma_reservation_cache_get_db_fields($main_cache_fields),
	  'indexes' => $indexes,
	  'primary key' => array('cache_id'),
	  );

  return $schema;
}

/**
 * Function array of fields to add to the cma_reservation_cache table. Many of
 * the fields are added by looking at the fields currently on the main 
 * reservations content type
 */
function cma_reservation_cache_get_db_fields($main_cache_fields = array()) {
  $fields = $main_cache_fields;

  $skip_types = array(
		      'viewfield',
		      );

  $skip_names = array(
		      'field_reservations_inventory'
		      );
  $fields_info = field_info_instances('node', 'reservations_reservation');
  foreach ($fields_info as $field_name => $value) {
    $field_info = field_info_field($field_name);
    if (in_array($field_info['type'], $skip_types)) {
      continue;
    }
    if (in_array($field_name, $skip_names)) {
      continue;
    }

    if ($field_info['type'] == 'datetime' &&
	isset($field_info['columns']['value']) &&
	isset($field_info['columns']['value2'])) {

      $fields[$field_name."_start"] =
	cma_reservation_cache_db_field_type_info($field_info);
      $fields[$field_name."_end"] =
	cma_reservation_cache_db_field_type_info($field_info);
      
    }
    else {
    $fields[$field_name] =
      cma_reservation_cache_db_field_type_info($field_info);

    }
    unset($fields[$field_name]['not null']);
  }
  return $fields;
}

/**
 * Returns the main cache fields for the cma_reservation_cache table. The other
 * fields on the reservations_reservation will be used for the other columns
 */
function cma_reservation_cache_main_cache_fields() {
  $ret = array();
   
  $ret['cache_id'] = array('type' => 'serial',
			   'description' => 'Cache Primary Key',
			      );
  $ret['cache_time'] = array(
			     'type' => 'datetime',
			     'mysql_type' => 'datetime',
			     'not null' => TRUE,
			     'description' =>
			     'The time the cache was written',
			     );
  $ret['content_type'] =
    array(
	  'type' => 'varchar',
	  'length' => 255,
	  'default' => '',
	  'not null' => TRUE,
	  'description' =>
	  'human readable version of the reservable content type of the item',
	  );
  $ret['content_type_machine_name'] =
    array(
	  'type' => 'varchar',
	  'length' => 255,
	  'default' => '',
	  'not null' => TRUE,
	  'description' =>
	  'machine name of the reservable content type of the item',
	  );

  $ret['bucket_slot_id'] = array(
				 'type' => 'int',
				 'unsigned' => TRUE,
				 'not null' => TRUE,
				 );
  
  $ret['cache_slot_start_time'] = array(
			     'type' => 'int',
			     'unsigned' => TRUE,
			     'not null' => TRUE,
			     );
  $ret['cache_slot_end_time'] = array(
			   'type' => 'int',
			   'unsigned' => TRUE,
			   'not null' => TRUE,
			   );
  $ret['cache_slot_status'] = array(
				    'type' => 'int',
				    'unsigned' => TRUE,
				    'not null' => TRUE,
				    );
  $ret['inventory'] = array(
			    'type' => 'int',
			    'unsigned' => TRUE,
			    );
  $ret['inventory_name'] = array(
				 'type' => 'varchar',
				 'length' => 255,
				 'default' => '',
				 'description' =>
				 'Term name of inventory',
			     );

  $ret['bucket_category'] = array(
				  'type' => 'int',
				  'unsigned' => TRUE,
				  );
  $ret['bucket_category_name'] = array(
				       'type' => 'varchar',
				       'length' => 255,
				       'default' => '',
				       'description' =>
				       'Term name of bucket category',
			     );
    
  $ret['bucket_weight'] = array(
				'type' => 'int',
				'unsigned' => FALSE,
				);
  $ret['item_nid'] = array(
			   'type' => 'int',
			   'unsigned' => TRUE,
			   );
  $ret['item_title'] = array(
			     'type' => 'varchar',
			     'length' => 255,
			     'default' => '',
			     'description' =>
			     'Title of the node of a reservable content '.
			     'type',
			     );
  $ret['item_status'] = array(
			      'type' => 'int',
			      'unsigned' => TRUE,
			      );

  $ret['reservation_nid'] = array(
				  'type' => 'int',
				  'unsigned' => TRUE,
				  );
  $ret['reservation_group_id'] = array(
				       'type' => 'int',
				       'unsigned' => TRUE,
				       );
  $ret['reservation_status'] = array(
				     'type' => 'int',
				     'unsigned' => TRUE,
				     );
  $ret['project_nid'] = array(
			      'type' => 'int',
			      'unsigned' => TRUE,
			      );
  $ret['project_title'] = array(
				'type' => 'varchar',
				'length' => 255,
				'default' => '',
				'description' =>
				'Title of the project node associated  '.
				'with the reservation',
				);

  return $ret;
}


/**
 * Function is passed an array of information about the drupal field,
 * it uses that information to create and array for use in hook_schema
 *
 * @param $field_info drupal field info array
 * @return $info db field info array
 */
function cma_reservation_cache_db_field_type_info($field_info) {
  $info = array();
  switch ($field_info['type']) {
  case 'computed':
    $db_settings = $field_info['settings']['database'];
    $info['type'] = $db_settings['data_type'];
    //find computed field settings to set our db cache field settings
    if ($db_settings['data_type'] == 'int' ||
	$db_settings['data_type'] == 'float' ) {
      $info['size'] = $db_settings['data_size'];
    }
    if ($db_settings['data_type'] == 'varchar' ||
	$db_settings['data_type'] == 'text' ) {
      if ($field_info['settings']['store'] == 1) {
	$info['length'] = $db_settings['data_length'];	
      }
      else {
	//FIXME WHAT SHOULD I SET IT TO? HARD TO SAY SINCE THIS COMPUTED FIELD
	//IS NOT ACTUALLY STORED IN DB
	$info['length'] = 1000;
      }
    }
    else if ($db_settings['data_type'] == 'numeric') {
      $info['precision'] = $db_settings['data_precision'];
      $info['scale'] = $db_settings['data_scale'];
    }
    
    break;
    
  case 'entityreference':
    $info = $field_info['columns']['target_id'];
    break;
    
  case 'taxonomy_term_reference':
    $info = $field_info['columns']['tid'];
    break;

  case 'datetime':
  case 'number_integer':
  case 'text':
  case 'text_long':
  default:
    $info = $field_info['columns']['value'];
    break;
    
  }
  return $info;
}
